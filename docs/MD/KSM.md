---
title: 笔记：快速幂
date: 2021-10-06
cover: https://kilzo.coding.net/p/Kilzo/d/Blog-data/git/raw/master/Picture-md/picture_15_.webp
categories: 
 - 算法
tags:
 - C++算法笔记
---

# 快速幂（暂无矩阵版）

> 这几天系统学了一下快速幂，为什么说是这几天呢，其实是几分钟学了，然后摸了几天才写。现在记录一下加深一下记忆。emmm，由于是从**别人**那学来的，所以**代码**跟大家都**差不多**。也可以说是**完全一致**。。。。希望看到的**大佬**不要喷我，我还是个**菜鸡**。。。。好了，废话不多说，开始了。

## 首先我们先来了解一下为什么要快速幂？

幂运算都会写，但是当指数非常大的时候，普通的幂运算效率会显得十分低下，这个时候就需要快速幂来提高运算效率，从而优化时间复杂度。

## 然后如何写快速幂？

最简单的做法是通过指数运算达到。简单的说估计也看不明白。下面我给一个简单的例子。

假设我们要求$2^{1000}$,那么可以化为$2^{1000}=2^{500}\times2^{500}$,继而$2^{500}$可以细分为$2^{500}=2^{250}\times 2^{250}$，一直分到不能再分。这样计算比单纯的$2\times2$快了不少。大幅度提高了效率，所以叫做快速幂。

## 最后快速幂的写法和调优（以下内容从知乎中搬过来并略作修改）

### 递归快速幂

以上介绍的可以用一个递归方程概括：

![21-10-6-1](~@pos/21-10-6-1.png)

```cpp
//递归快速幂
int qpow(int a, int n)
{
    if (n == 0)
        return 1;
    else if (n % 2 == 1)
        return qpow(a, n - 1) * a;
    else
    {
        int temp = qpow(a, n / 2);
        return temp * temp;
    }
}
```

注意，这个temp变量是必要的，因为如果不把$a^{\frac n 2}$记录下来，直接写成`qpow(a, n /2)*qpow(a, n /2)`，那会计算两次$a^{\frac n 2}$，整个算法就退化为了 $O(N)$。

---

在实际问题中，题目常常会要求对一个大素数取模。

```cpp
//递归快速幂（对大素数取模）
#define MOD 1000000007
typedef long long ll;
ll qpow(ll a, ll n)
{
    if (n == 0)
        return 1;
    else if (n % 2 == 1)
        return qpow(a, n - 1) * a % MOD;
    else
    {
        ll temp = qpow(a, n / 2) % MOD;
        return temp * temp % MOD;
    }
}
```

大家知道，递归虽然**简洁**，但会产生**额外的空间开销**。我们可以把递归改写为循环，来避免对栈空间的大量占用，也就是**非递归快速幂**。

---

### 非递归快速幂

我们换一个角度来引入非递归的快速幂。7的10次方，我们把10写成**二进制**的形式，也就是$(1010)_2$ 。

现在我们要计算 $7^{(1010)_2}$ ，可以把它拆分为  $7^{(1000)_2}\times7^{(10)_2}$. 实际上，对于任意的整数，我们都可以把它拆成若干个$7^{(100…)_2}$的形式相乘。而这些$7^{(100…)_2}$，恰好就是$7^1$、$7^2$、$7^4$……我们只需**不断把底数平方**就可以算出它们。

```cpp
//非递归快速幂
int qpow(int a, int n){
    int ans = 1;
    while(n){
        if(n&1)        //如果n的当前末位为1
            ans *= a;  //ans乘上当前的a
        a *= a;        //a自乘
        n >>= 1;       //n往右移一位
    }
    return ans;
}
```

最初ans为1，然后我们一位一位算：

1010的最后一位是0，所以$a^1$这一位不要。然后1010变为101，a变为$a^2$。

101的最后一位是1，所以$a^2$这一位是需要的，乘入ans。101变为10，a再自乘。

10的最后一位是0，跳过，右移，自乘。

然后1的最后一位是1，ans再乘上$a^8$。循环结束，返回结果。

![img](https://pic3.zhimg.com/80/v2-e99e321dcff33699093cde2876424dbe_1440w.jpg)

这里的位运算符，**>>**是右移，表示把二进制数**往右移一位**，相当于/2；&是按位与，&1可以理解为**取出二进制数的最后一位**，相当于%2==1。这么一等价，是不是看出了递归和非递归的快速幂的关系了？虽然非递归快速幂因为牵扯到二进制理解起来稍微复杂一点，但基本思路其实和递归快速幂没有太大的出入。

------

## 快速幂的拓展

上面所述的都是**整数**的快速幂，但其实，在算 ![[公式]](https://www.zhihu.com/equation?tex=a%5En) 时，只要a的数据类型支持**乘法**且**满足结合律**，快速幂的算法都是有效的。矩阵、高精度整数，都可以照搬这个思路。下面给出一个模板：

```cpp
//泛型的非递归快速幂
template <typename T>
T qpow(T a, ll n)
{
    T ans = 1; // 赋值为乘法单位元，可能要根据构造函数修改
    while (n)
    {
        if (n & 1)
            ans = ans * a; // 这里就最好别用自乘了，不然重载完*还要重载*=，有点麻烦。
        n >>= 1;
        a = a * a;
    }
    return ans;
}
```

注意，较复杂类型的快速幂的时间复杂度不再是简单的 ![[公式]](https://www.zhihu.com/equation?tex=O%28%5Clog+n%29) ，它与底数的乘法的时间复杂度有关。

例如，**矩阵快速幂**的一个经典应用是求斐波那契数列：

## 完

